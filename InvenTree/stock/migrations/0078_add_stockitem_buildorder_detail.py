# Generated by Django 3.2.13 on 2022-06-22 23:07

from InvenTree.status_codes import StockHistoryCode

from django.db import migrations
from django.db.models import Q

def remove_buildorder_deltas(apps, schema_editor):
  """Back out this mgiration by removing all 'buildorder' keys in the deltas field of StockItemTracking objects."""
  StockItemTracking = apps.get_model('stock', 'StockItemTracking')
  for item in StockItemTracking.objects.filter(tracking_type=StockHistoryCode.BUILD_CONSUMED):
    if 'buildorder' not in item.deltas:
      continue
    del item.deltas['buildorder']
    item.save()

def get_bom_items(apps, part):
  """Hack around lack of access to custom Model methods in Django migrations. Rebuild BOM query logic!"""
  BomItem = apps.get_model('part', 'BomItem')

  bom_filter = Q(part=part)
  # Naively try and walk the parent tree.
  nextpart = part.variant_of
  while nextpart:
    bom_filter |= Q(part=nextpart)
    nextpart = nextpart.variant_of
  
  return BomItem.objects.filter(bom_filter)

def match_buildorders(apps, schema_editor):
  """Try and heuristically/best-effort match previous build orders to tracking entries and add the new metadata.

  The heuristic match is on the entry time, bom item and quantity, 
  if those match uniquely a link is established. If not we just give up.
  """
  StockItemTracking = apps.get_model('stock', 'StockItemTracking')
  Build = apps.get_model('build', 'Build')
  for tracking_item in StockItemTracking.objects.filter(tracking_type=StockHistoryCode.BUILD_CONSUMED):
    if tracking_item.item.part.trackable:
      continue  # Serialized items are already associated via installation. 
    
    quantity = tracking_item.deltas['removed']
    matched_orders = []
    #print(f'-- looking for matches for {quantity} {tracking_item.item.part.name}\'s consumed on {tracking_item.date}')
    for o in Build.objects.filter(completion_date=tracking_item.date):
      #print(f' + considering order {o.pk} from {o.completion_date}')
      for item in get_bom_items(apps, o.part):
        if item.sub_part.pk != tracking_item.item.part.pk:
          continue
        used_quantity = o.completed * item.quantity
        if used_quantity == quantity:
          #print(f'  + Matched {tracking_item.item.part.name} to {item.sub_part.name} (used {used_quantity}) in build order {o.pk}')
          matched_orders.append(o)
          break

    if len(matched_orders) != 1:
      #print(f' ! Can\'t match {tracking_item.item.part.name}. {len(matched_orders)} orders found!')
      continue  # Heuristic can't find a unique match, give up. 
    #print(f' * Matching {tracking_item.item.part.name} to build order {matched_orders[0].pk}')
    tracking_item.deltas['buildorder'] = matched_orders[0].pk
    tracking_item.save()


class Migration(migrations.Migration):

    dependencies = [
        ('stock', '0077_alter_stockitem_notes'),
    ]

    operations = [
        migrations.RunPython(match_buildorders, remove_buildorder_deltas)
    ]
